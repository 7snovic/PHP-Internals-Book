<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Strings management : zend_string &mdash; PHP Internals Book</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/style.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="PHP Internals Book" href="../index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>PHP Internals Book</span></a></h1>
        <h2 class="heading"><span>Strings management : zend_string</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="strings-management-zend-string">
<h1>Strings management : zend_string<a class="headerlink" href="#strings-management-zend-string" title="Permalink to this headline">¶</a></h1>
<p>Any program needs to manage strings. Here, we&#8217;ll detail the zend_string structure which helps for that.
Every time PHP needs to work with a string, a zend_string structure will be used. This structure is just a simple
thin wrapper over the char * string type of the C language.</p>
<p>It adds memory management facilities, so that a same string can be shared in several places without the need to
duplicate it. Also, some strings are &#8220;interned&#8221;, that is they are &#8220;persistent&#8221; allocated and specialy managed by the
memory manager so that they don&#8217;t get destroyed across several requests.</p>
<div class="section" id="structure-and-access-macros">
<h2>Structure and access macros<a class="headerlink" href="#structure-and-access-macros" title="Permalink to this headline">¶</a></h2>
<p>Here is the simple zend_string structure explosed:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="k">struct</span> <span class="n">_zend_string</span> <span class="p">{</span>
        <span class="n">zend_refcounted_h</span> <span class="n">gc</span><span class="p">;</span>
        <span class="n">zend_ulong</span>        <span class="n">h</span><span class="p">;</span>
        <span class="kt">size_t</span>            <span class="n">len</span><span class="p">;</span>
        <span class="kt">char</span>              <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Like you can see, the structure embeds a <tt class="docutils literal"><span class="pre">zend_refcounted_h</span></tt> header. This is done for memory management and reference
counting, as you may have learnt by reading the <tt class="xref doc docutils literal"><span class="pre">php7/memory_management</span></tt> chapter.
As the string is very likely to be used as the key of a HashTable probe, it embeds its hash in the <tt class="docutils literal"><span class="pre">h</span></tt> field. This is
an unsigned long <tt class="docutils literal"><span class="pre">zend_ulong</span></tt>. This number is only used when the <tt class="docutils literal"><span class="pre">zend_string</span></tt> needs to be hashed, aka especially
when used together with <tt class="xref doc docutils literal"><span class="pre">/php7/hashtables</span></tt>; this is very likely though.</p>
<p>As you know, the string knows its length as the <tt class="docutils literal"><span class="pre">len</span></tt> field, to support &#8220;binary strings&#8221;. Binary strings are
strings that embeds one or several <tt class="docutils literal"><span class="pre">NUL</span></tt> characters (\0). When passed to libc functions, those strings will get
truncated or their length won&#8217;t be computed the right way. So in <tt class="docutils literal"><span class="pre">zend_string</span></tt>, the length of the string is always
known. Please, note that the length computes the number of ASCII chars (bytes) not counting the terminating <tt class="docutils literal"><span class="pre">NUL</span></tt>, but
counting the eventual middle NULs. For example, the string &#8220;foo&#8221; is stored as &#8220;foo\0&#8221; in a <tt class="docutils literal"><span class="pre">zend_string</span></tt> and its
length is then 3. Also, the string &#8220;foo\0bar&#8221; will be stored as &#8220;foo\0bar\0&#8221; and the length will be 7.</p>
<p>Finally, the characters are stored into the <tt class="docutils literal"><span class="pre">char[1]</span></tt> field. This is not a <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>, but a <tt class="docutils literal"><span class="pre">char[1]</span></tt>. Why that ?
This is a memory optimization known as &#8220;C struct hack&#8221; (you may use a search engine with these terms). Basically, that
allows the engine to allocate space for the <tt class="docutils literal"><span class="pre">zend_string</span></tt> structure and the charcaters to be stored, as one solo C
pointer. This optimizes memory accesses as memory will be a contiguous allocated block, and not two blocks sparsed in
memory (one for <tt class="docutils literal"><span class="pre">zend_string</span> <span class="pre">*</span></tt>, and one for the <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt> to store into it).</p>
<p>This struct hack must be remembered, as the memory layout looks like with the C chars at the end of the C <tt class="docutils literal"><span class="pre">zend_string</span></tt>
structure, and may be felt/seen when using a C debugger (or when debugging strings). This hack is entirely managed by
the API you&#8217;ll use when manipulating <tt class="docutils literal"><span class="pre">zend_string</span></tt> structures.</p>
</div>
<div class="section" id="using-zend-string-api">
<h2>Using zend_string API<a class="headerlink" href="#using-zend-string-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="simple-use-case">
<h3>Simple use case<a class="headerlink" href="#simple-use-case" title="Permalink to this headline">¶</a></h3>
<p>Like with <a class="reference internal" href="zvals.html"><em>Zvals</em></a>, you dont manipulate the <tt class="docutils literal"><span class="pre">zend_string</span></tt> internals fields by hand, but always use macros
for that. There also exists macros to trigger actions on strings. Those are not functions but macros, all stored into
the required <tt class="docutils literal"><span class="pre">Zend/zend_string.h</span></tt> header:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

<span class="n">str</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;It is %zd char long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>The above simple example show you basic string management. The <tt class="docutils literal"><span class="pre">zend_string_init()</span></tt> function (which in fact is a macro,
but let&#8217;s pass such details) should be given your full C string as a <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>, and its length. The last parameter- of
type int- should be 0 or 1.
If you pass 0, you ask the engine to use a request-bound heap allocation using the Zend Memory Manager. Such allocation
will be destroyed at the end of the current request. If you don&#8217;t do it yourself, on a debug build, the engine will
shout at you about a memory leak you just created.
If you pass 1, you ask for what we called a &#8220;persistent&#8221; allocation, that is the engine will use a traditionnal C
<tt class="docutils literal"><span class="pre">malloc()</span></tt> call and will not track the memory allocation in any way.</p>
<p>Then, we display the string. We access the character array by using the <tt class="docutils literal"><span class="pre">ZSTR_VAL()</span></tt> macro. <tt class="docutils literal"><span class="pre">ZSTR_LEN()</span></tt> allows
access to the length informations. Like with zvals, you always use macros to access the structure fields and don&#8217;t do
that by hand yourself. zend_string related macros all start with <tt class="docutils literal"><span class="pre">ZSTR_**()</span></tt>, beware that is not the same as
<tt class="docutils literal"><span class="pre">Z_STR**()</span></tt> macros.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The length is stored using a <tt class="docutils literal"><span class="pre">size_t</span></tt> type. Hence, to display it, &#8220;%zd&#8221; is necessary for printf(). You
should always use the right printf() formats. Failing to do that can crash the application or create security
issues. For a nice recall on printf() formats, please visit
<a class="reference external" href="http://www.cplusplus.com/reference/cstdio/printf/">this link</a></p>
</div>
<p>Finally, we release the string using <tt class="docutils literal"><span class="pre">zend_string_release()</span></tt>. This release is mandatory. This is about memory management.
The &#8220;releasing&#8221; is a simple operation : decrement the reference counter of the string, if it falls to zero, the API will
free the string for you. If you forget to release a string, you will very likely create a memory leak.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You must always think about memory management in C. If you allocate - whether directly using malloc(), or
using an API that will do it for you - you must free at some point. Failing to do that will create memory
leaks and translate into a badly designed program that nobody will be able to use safely.</p>
</div>
</div>
<div class="section" id="playing-with-the-hash">
<h3>Playing with the hash<a class="headerlink" href="#playing-with-the-hash" title="Permalink to this headline">¶</a></h3>
<p>If you need to access the hash, use <tt class="docutils literal"><span class="pre">ZSTR_H()</span></tt>. However, the hash is not computed automatically when you create your
<tt class="docutils literal"><span class="pre">zend_string</span></tt>. It will be done for you however when using that string with the HashTable API.
If you want to force the hash to get computed now, use <tt class="docutils literal"><span class="pre">ZSTR_HASH()</span></tt> or <tt class="docutils literal"><span class="pre">zend_string_hash_val()</span></tt>.
Once the hash is computed, it is saved and never computed again. If for any reason, you need to recompute it - f.e
because you changed the value of the string - use <tt class="docutils literal"><span class="pre">zend_string_forget_hash_val()</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">str</span><span class="p">;</span>

<span class="n">str</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;It is %zd char long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_hash_val</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string hash is %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_H</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

<span class="n">zend_string_forget_hash_val</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string hash is now cleared back to 0!&quot;</span><span class="p">);</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="string-copy-and-memory-management">
<h3>String copy and memory management<a class="headerlink" href="#string-copy-and-memory-management" title="Permalink to this headline">¶</a></h3>
<p>One very nice feature of <tt class="docutils literal"><span class="pre">zend_string</span></tt> API is that it allows one part to &#8220;own&#8221; a string by simply declaring interest
with it. The engine will then not duplicate the string in memory, but simply increment its refcount
(as part of its zend_refcounted_h). This allows sharing a single piece of memory in many places into the code.</p>
<p>That way, when we talk about &#8220;copying&#8221; a <tt class="docutils literal"><span class="pre">zend_string</span></tt>, in fact we don&#8217;t copy anything in memory. If needed- that is
still a possible operation- we then talk about &#8220;duplicating&#8221; the string. Here we go:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="o">*</span><span class="n">bar2</span><span class="p">,</span> <span class="o">*</span><span class="n">baz</span><span class="p">;</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* creates the &quot;foo&quot; string in foo */</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* creates the &quot;bar&quot; string in bar */</span>

<span class="cm">/* creates bar2 and shares the &quot;bar&quot; string from bar into bar2.</span>
<span class="cm">   Also increments the refcount of the &quot;bar&quot; string to 2 */</span>
<span class="n">bar2</span> <span class="o">=</span> <span class="n">zend_string_copy</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;We just copied two strings</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;See : bar content : %s, bar2 content : %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar2</span><span class="p">));</span>

<span class="cm">/* Duplicate in memory the &quot;bar&quot; string, create the baz variable and</span>
<span class="cm">   make it solo owner of the newly created &quot;bar&quot; string */</span>
<span class="n">baz</span> <span class="o">=</span> <span class="n">zend_string_dup</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;We just duplicated &#39;bar&#39; in &#39;baz&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;Now we are free to change &#39;baz&#39; without fearing to change &#39;bar&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="cm">/* Change the last char of the second &quot;bar&quot; string</span>
<span class="cm">   turning it to &quot;baz&quot; */</span>
<span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">baz</span><span class="p">)[</span><span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">baz</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;z&#39;</span><span class="p">;</span>

<span class="cm">/* Forget the old hash (if computed) as now the string changed, thus</span>
<span class="cm">   its hash must also change and get recomputed */</span>
<span class="n">zend_string_forget_hash_val</span><span class="p">(</span><span class="n">baz</span><span class="p">);</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;&#39;baz&#39; content is now %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">baz</span><span class="p">));</span>

<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>  <span class="cm">/* destroys (frees) the &quot;foo&quot; string */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>  <span class="cm">/* decrements the refcount of the &quot;bar&quot; string to one */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar2</span><span class="p">);</span> <span class="cm">/* destroys (frees) the &quot;bar&quot; string both in bar and bar2 vars */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">baz</span><span class="p">);</span>  <span class="cm">/* destroys (frees) the &quot;baz&quot; string */</span>
</pre></div>
</div>
<p>We start by just allocating &#8220;foo&#8221; and &#8220;bar&#8221;. Then we create the <tt class="docutils literal"><span class="pre">bar2</span></tt> string as being a copy of <tt class="docutils literal"><span class="pre">bar</span></tt>. Here, everybody
must remember : <tt class="docutils literal"><span class="pre">bar</span></tt> and <tt class="docutils literal"><span class="pre">bar2</span></tt> point to <em>the same</em> C string in memory, and changing one will change the second
one. This is <tt class="docutils literal"><span class="pre">zend_string_copy()</span></tt> behavior : it just increments the refcount of the owned C string.</p>
<p>If we want to separate the strings- aka we want to have two different copies of that string in memory -we need to
duplicate using <tt class="docutils literal"><span class="pre">zend_string_dup()</span></tt>. We then duplicate <tt class="docutils literal"><span class="pre">bar2</span></tt> variable string into the <tt class="docutils literal"><span class="pre">baz</span></tt> variable. Now, the
<tt class="docutils literal"><span class="pre">baz</span></tt> variable embeds its own copy of the string, and can change it without impacting <tt class="docutils literal"><span class="pre">bar2</span></tt>. That is what we do :
we change the final &#8216;r&#8217; in &#8216;bar&#8217; with a &#8216;z&#8217;, for &#8216;baz&#8217;. And then we display it, and free memory of every string.</p>
<p>Note that we forgot the hash value (if it were computed before, no need to think about that detail). This is a good
practice to remember about. Like we already said, the hash is used if the <tt class="docutils literal"><span class="pre">zend_string</span></tt> is used as part of HashTables.
This is a very common operation in development, and changing a string value requires to recompute the hash value as
well. Forgetting such a step will lead to bugs that could cost some time to track.</p>
</div>
<div class="section" id="string-operations">
<h3>String operations<a class="headerlink" href="#string-operations" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">zend_string</span></tt> API allows other operations, such as extending or shrinking strings, changing their case or comparing
them. There is no concat operation available yet, but that is pretty easy to perform:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zend_string</span> <span class="o">*</span><span class="n">foo</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">,</span> <span class="o">*</span><span class="n">foobar</span><span class="p">,</span> <span class="o">*</span><span class="n">lc</span><span class="p">;</span>

<span class="n">foo</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;FOO&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;FOO&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">bar</span> <span class="o">=</span> <span class="n">zend_string_init</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Compares a zend_string against a C string litteral */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zend_string_equals_literal</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&quot;foobar&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">foobar</span> <span class="o">=</span> <span class="n">zend_string_copy</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

    <span class="cm">/* realloc()ates the C string to a larger buffer */</span>
    <span class="n">foobar</span> <span class="o">=</span> <span class="n">zend_string_extend</span><span class="p">(</span><span class="n">foobar</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;foobar&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

    <span class="cm">/* concatenates &quot;bar&quot; after the newly reallocated large enough &quot;foo&quot; */</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foobar</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">foo</span><span class="p">),</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">bar</span><span class="p">),</span> <span class="n">ZSTR_LEN</span><span class="p">(</span><span class="n">bar</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is my new string: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">foobar</span><span class="p">));</span>

<span class="cm">/* Compares two zend_string together */</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">zend_string_equals</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="n">foobar</span><span class="p">))</span> <span class="p">{</span>
    <span class="cm">/* duplicates a string and lowers it */</span>
    <span class="n">lc</span> <span class="o">=</span> <span class="n">zend_string_tolower</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;This is in LC: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ZSTR_VAL</span><span class="p">(</span><span class="n">lc</span><span class="p">));</span>

<span class="cm">/* frees memory */</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">bar</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">foobar</span><span class="p">);</span>
<span class="n">zend_string_release</span><span class="p">(</span><span class="n">lc</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="zend-string-access-with-zvals">
<h3>zend_string access with zvals<a class="headerlink" href="#zend-string-access-with-zvals" title="Permalink to this headline">¶</a></h3>
<p>Now that you know how to manage and manipulate zend_string , let&#8217;s see the interaction they got with zvals.
You need to be familiar with zvals, if not, read the <a class="reference internal" href="zvals.html"><em>Zvals</em></a> dedicated chapter.</p>
<p>The macros will allow you to store a <tt class="docutils literal"><span class="pre">zend_string</span></tt> into a <tt class="docutils literal"><span class="pre">zval</span></tt>, or to read the <tt class="docutils literal"><span class="pre">zend_string</span></tt> from a <tt class="docutils literal"><span class="pre">zval</span></tt>:</p>
<div class="highlight-c"><div class="highlight"><pre><span class="n">zval</span> <span class="n">myval</span><span class="p">;</span>
<span class="n">zend_string</span> <span class="o">*</span><span class="n">hello</span><span class="p">,</span> <span class="o">*</span><span class="n">world</span><span class="p">;</span>

<span class="n">zend_string_init</span><span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;hello&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Stores the string into the zval */</span>
<span class="n">ZVAL_STR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myval</span><span class="p">,</span> <span class="n">hello</span><span class="p">);</span>

<span class="cm">/* Reads the C string, from the zend_string from the zval */</span>
<span class="n">php_printf</span><span class="p">(</span><span class="s">&quot;The string is %s&quot;</span><span class="p">,</span> <span class="n">Z_STRVAL</span><span class="p">(</span><span class="n">myval</span><span class="p">));</span>

<span class="n">zend_string_init</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;world&quot;</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Changes the zend_string into myval : replaces it by another one */</span>
<span class="n">Z_STR</span><span class="p">(</span><span class="n">myval</span><span class="p">)</span> <span class="o">=</span> <span class="n">world</span><span class="p">;</span>
</pre></div>
</div>
<p>What you must memorize is that every macro beginning by <tt class="docutils literal"><span class="pre">ZSTR_***(s)</span></tt> will act on a <tt class="docutils literal"><span class="pre">zend_string</span></tt>.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ZSTR_VAL()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ZSTR_LEN()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">ZSTR_HASH()</span></tt></li>
<li>...</li>
</ul>
<p>Every macro beginning by <tt class="docutils literal"><span class="pre">Z_STR**(z)</span></tt> will act on a <tt class="docutils literal"><span class="pre">zend_string</span></tt> itself embeded into a <tt class="docutils literal"><span class="pre">zval</span></tt></p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Z_STRVAL()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Z_STRLEN()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">Z_STRHASH()</span></tt></li>
<li>...</li>
</ul>
<p>A few other that you won&#8217;t probably need also exist.</p>
</div>
<div class="section" id="classical-c-strings">
<h3>Classical C strings<a class="headerlink" href="#classical-c-strings" title="Permalink to this headline">¶</a></h3>
<p>Just a quick note about classical C strings. In C, strings are character arrays (<tt class="docutils literal"><span class="pre">char</span> <span class="pre">foo[]</span></tt>), or pointers to
characters (<tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></tt>). They don&#8217;t know anything about their length, that&#8217;s why they are NUL terminated (knowing the
beginning of the string and its end, you know its length).</p>
<p>Before PHP 7, <tt class="docutils literal"><span class="pre">zend_string</span></tt> structure simply did not exist. A traditionnal <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></tt> couple were used back in
that time. You may still find rare places into PHP where <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></tt> couple is used instead of <tt class="docutils literal"><span class="pre">zend_string</span></tt>.
You may also find API facilities to interact between a <tt class="docutils literal"><span class="pre">zend_string</span></tt> on one side, and a <tt class="docutils literal"><span class="pre">char</span> <span class="pre">*</span> <span class="pre">/</span> <span class="pre">int</span></tt> couple on
the other side.</p>
<p>Whereever it is possible : make use of <tt class="docutils literal"><span class="pre">zend_string</span></tt>.</p>
</div>
<div class="section" id="interned-zend-string">
<h3>Interned zend_string<a class="headerlink" href="#interned-zend-string" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../index.html">Contents</a>
        </p>

      </div>

    <div class="footer feedback">
        The repository for this book is available on <a href="https://github.com/phpinternalsbook/PHP-Internals-Book">GitHub</a>.
        <br/><br/>
        <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">
            <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" />
        </a>
        <br />
        The PHP internals book is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
    </div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-41617167-1', 'phpinternalsbook.com');
      ga('send', 'pageview');
    </script>

  </body>
</html>